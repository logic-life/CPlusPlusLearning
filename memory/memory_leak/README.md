## **类型泄露常见方式**

```
//第一种情况，当给void指针释放内存时，会造成内存泄露
	void *str1 = new memory_leak_first('a', 3);
	memory_leak_first  *str2 = new memory_leak_first('c', 3);	/*static_cast<memory_leak_first*>(str1)->~memory_leak_first();*/
	//硬释放，将void类型转化为memory_leak_first类型，然后显示指定析构函数
	delete str1;
	delete str2;
	//第二种情况，忘记给释放内存
	//set_new_handler(out_of_memory);
	//while (1) {
	//
	//	new int[1000];
	//
	//}
	//第三种情况，释放内存不完全
	/*Test* object1 = new Test[100];
	Test *object2 = new Test[100];
	delete[]object1;
	delete[]object2;*/
```

**内存泄露**：是因为由于调用了molloc或者new等内存操作的操作，但是缺少了对应的free和delete操作。为了判断是否内存泄漏，我们一方面可以使用Linux下的内存泄露检查工具**Valgrind**,另一方面我们可以在写代码的时候添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

**内存溢出和内存泄露：**

内存溢出指申请内存时，没有足够的内存供申请者使用。内存溢出就是申请的内存空间超过系统实际分配的空间，就会报内存溢出的错误。

内存溢出的原因：

+ **内存中加载的数据量过于庞大，如一次从数据库取出过多数据**
+ **代码中存在死循环或循环产生过多重复的对象实体**
+ **启动参数内存值设定的过小**
+ **集合类中有对对象的引用，使用完后未清空，使得不能回收**
+ **使用的第三方软件中存在bug**

**内存泄露是指由于疏忽或错误造成了程序未释放掉不在使用的内存的情况。内存泄露并非是指内存物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因此造成了内存的浪费。**

内存泄露的分类：

* [X] 1、堆内存泄露（Heap leak）：是因为由于调用了molloc或者new等内存操作的操作，但是缺少了对应的free和delete操作。如果程序的设计的错误导致这部分内存没有释放，则此后的这块内存将不会被使用，就会产生Heap Leak。
* [ ] 2、系统资源泄露（Resource leak）。主要指程序使用系统分配的资源比如Bitmap,handle,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重时可导致系统效能降低，系统运行不稳定。

* [ ] 3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual,那么子类的析构函数将不会被调用，子类的资源不会被正确释放，因此造成内存泄露。
