# 多态

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉**编译器不要静态链接到该函数**。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为 **动态链接** ，或 **后期绑定** 。

```
class Shape
{
protected:
    int width, height;

public:
    Shape(int a = 0, int b = 0)
    {
        width = a;
        height = b;
    }
    // 此时调用时不会根据变量的类型来调用而是根据对象的指针内容
    virtual int area()
    {
        cout << "Parent class area :" << endl;
        return 0;
    }
};
class Rectangle : public Shape
{
public:
    Rectangle(int a = 0, int b = 0) : Shape(a, b) {}
    int area()
    {
        cout << "Rectangle class area :" << endl;
        return (width * height);
    }
};
class Triangle : public Shape
{
public:
    Triangle(int a = 0, int b = 0) : Shape(a, b) {}
    int area()
    {
        cout << "Triangle class area :" << endl;
        return (width * height / 2);
    }
};
```

**纯虚函数** 当想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

我们可以把基类中的虚函数 area() 改写如下：

```
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
};
```

## 函数初始化列表

省略初始化列表在构造函数的函数体内对数据成员进行赋值是合法的。

概念上，构造函数分为两个阶段执行：

1）初始化阶段；

2）普通的计算阶段，即函数体内的语句计算。

初始化发生在计算阶段之前，计算阶段是赋值操作

对于内置类型是否在列表初始化无所谓，但是对于类类型成员，在函数体内赋值，则要先调用自身默认构造函数进行初始化，然后再赋值，效率较低！

**没有默认构造函数的类的成员在，以及const类型的成员变量以及引用类型的成员变量，都必须在构造函数初始化列表中进行初始化。**

## 拷贝构造函数

特点：只有单个形参，且必须为自身对象的引用，否则会造成循环调用！用于另一个同类型的对象初始化另一个对象。

什么时候会发生拷贝初始化：

1.将一个对象作为实参传递给一个非引用类型的实参(引用作为参数的话就可以省略拷贝这一操作，所以有时候可以这样来优化代码)

2.从一个返回类型为非引用的函数返回一个对象

3.花括号初始化一个数组的元素或一个聚合类（struct）的成员

## 啥是浅拷贝，啥是深拷贝

浅拷贝：简单的复制拷贝操作，位拷贝，简单的把值复制过来，实质上还是一个对象。系统默认的拷贝构造函数，就是浅拷贝！

深拷贝：在堆区重新申请内存空间，把资源复制过来，进行拷贝操作，相当于两个对象了。stl中的vector、stack、queue、set、map均是深拷贝。对于对象中包含指针或者动态数组的成员，最好使用深拷贝，否则会出现未定义的行为，内存泄漏等错误！

```
 // 自己实现拷贝构造函数，解决浅拷贝带来的问题
    Person(const Person &p)
    {
        cout << "Person拷贝造函数调用" << endl;
        m_Age = p.m_Age;
        // m_Height = p.m_Height; // 编译器默认实现就是这行代码(浅拷贝)
        // 深拷贝操作
        m_Height = new int(*p.m_Height);
    }
```

[浅拷贝与深拷贝](https://blog.csdn.net/u010700335/article/details/39830425)

[浅拷贝与深拷贝](http://c.biancheng.net/view/2336.html)

[浅拷贝与深拷贝](https://zhuanlan.zhihu.com/p/271332700)

## [啥是多态](https://zhuanlan.zhihu.com/p/28530472)

“多态（英语：polymorphism），是指计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作称之。”其实更简单地来说，就是“在用父类指针调用函数时，实际调用的是指针指向的实际类型（子类）的成员函数”。多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。

## 为啥构造函数不能被声明为虚函数，而析构函数最好被声明为虚函数

因为在构造函数被创建之前，各个对象中的成员变量并未初始化，自然虚函数指针也无法通过虚函数表找到对应的构造函数

理解为我想进这扇门，但是我的钥匙却在门内。

析构函数被声明为是因为，定义为一般函数时，会自动调用基类的析构函数，无法对子类的对象进行完全析构，而我们想析构一个对象时，肯定是想对对象的本身类型进行析构。
